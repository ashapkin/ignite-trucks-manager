Chapter 4

Utilizing the ComputGrid API to get the average characteristics.

Let's imagine that we want to iterate through the sensor's data collection and check whether there was some abnormal deviation that might refer to fuel theft. For simplicity, we will just compare the neighbors and check for a configured threshold. If the difference of the values is lower then a threshold, we'd say that everything was ok. 

We might iterate over the whole collection using the cache#get API, but this will require the whole data set to be transferred from a server to a client node. We might avoid these using the ComputAPI and send the compute task itself (source code) to a server rather than a data collection.

To do this, we declared the IgniteCompute.cs facade that will utilize the appropriate Ignite API. The #AnalyzeFuelConsumption method accepts a truckId, instantiate a new FuelConsumptionIgniteTask.cs object and calls ignite.GetCompute().CallAsync(task).

Under the hood, Ignite serializes the compute task into a binary format (with all other fields, so be careful here) and send it to a server node. The node then deserializes the task and executes it, sending back a result, in our case, it's Boolean object. 

Note, the current approach has a drawback: it's not obvious how can we use a DI framework within a callable. For sample, Ignite's internals allows us to mark an Ignite instance with [InstanceResourceAttribute], thus the instance will be auto injected on task deserialization. We can benefit from using a custom plugin and register a DI resolver instance within it.  We will check this approach later on. 